%% Normal Hash table

% Making the hash function
function index = simpleHash(ip, tableSize)
    %prime number used for hashing
    prime = 31; 
    hash = mod(prime*double(ip), 2^32); %Using 2^32 as int is 32 bits to avoid overflow

    index = mod(hash, tableSize)+1; %matlab indexing starts at 1
end

% Insert function for hash table. With chaining in case of collision
function hashTable = hashInsert(hashTable, ip, next, tableSize)
    index = simpleHash(ip, tableSize);
    
    %Check if the cell is empty
    if isempty(hashTable{index})
        hashTable{index} = {ip, next};
    else
        hashTable{index} = [hashTable{index}; {ip, next}];
    end
end

% Lookup function for the hash table
function result = hashLookup(hashTable, ip, tableSize)
    index = simpleHash(ip, tableSize);
    bucket = hashTable{index}; %bucket because of chaining

    result = "Miss"; %Assume it is a miss at the beginning
    if ~isempty(bucket)
        for i = 1:size(bucket, 1)
            if isequal(bucket{i, 1}, ip)
                result = bucket{i, 2};
                return;
            end
        end
    end
end


%% D-Left Hashing

% Hash function with a seed
function index = dLeftHash(ip, subtableSize, seed)
    prime = 31 + seed*2;
    hash = mod(prime*double(ip), 2^32);
    index = mod(hash, subtableSize)+1;
end

% Insert function for d-left hashing
function hashTable = dLeftInsert(hashTable, ip, next, d, subtableSize)
    minLen = inf; %Starting off at infinity for comparison
    chosenSub = 1; %Default starting sub table

    for i = 1:d
        index = dLeftHash(ip, subtableSize, i);
        if isempty(hashTable{i}{index}) %check if that space is empty
            hashTable{i}{index} = {ip, next};
            return;
        else 
            currentLen = length(hashTable{i}{index}); %Check the current length to find the subtable with the shortest length
            if currentLen < minLen
                minLen = currentLen;
                chosenSub = i;
                bestIndex = index;
            end
        end
    end

    %Insert the IP address into the least loaded subTable
    hashTable{chosenSub}{bestIndex}{end+1} = {ip, value}; %Chaining
end


%Look up function for d-left hashing
function result = dLeftLookup(hashTable, ip, d, subtableSize)
    result = "Miss";
    for i = 1:d %Look through all of the sub tables
        index = dLeftHash(ip, subtableSize, i);
        bucket = hashTable{i}{index};
        if ~isempty(bucket) % If the bucket is not empty
            for j = 1:length(bucket) %Look through all of the chained values
                if isequal(bucket{j}{1}, ip)
                    result = bucket{j}{2};
                    return;
                end
            end
        end
    end
    %Otherwise, it is a miss
end


%% Testing All the different algorithms
numberOfIPs = 10;
%Generate a list of IP addresses
function ipList = generateRandomIP(numberOfIPs)
    ipList = randi([0, 2^32-1], numberOfIPs, 1, 'uint32');
end

ipList = generateRandomIP(numberOfIPs);

%Generate the hash table of ips
hashTable = cell(1, numberOfIPs);
for i = 1:length(ipList)
    ip = ipList(i);
    hashInsert(hashTable, ip, i, numberOfIPs);
end

%Generate the d-left hash table of ips
d = 4; %number of sub tables
subtableSize = ceil(numberOfIPs/4); %Must contain all of the entries

%Iniitilize d-left hash table
dLeftHashTable = cell(1, d);
for i = 1:d
    hashTable{i} = cell(1, subtableSize);
end

%Insert the IPs into the hashTable
for i = 1:length(ipList)
    ip = ipList(i);
    dLeftInsert(dLeftHashTable, ip, d, subtableSize);
end

%Time lookup time
tic;
for i = 1:length(ipList)
    ip = ipList(i);
    next = hashLookup(hashTable, ip, numberOfIPs);
end
elapsedTime = toc;
fprintf('Average lookup time: %.6f ms\n', (elapsedTime / numberOfIPs) * 1000);